---
import type { CollectionEntry } from "astro:content";
import type { MarkdownHeading } from "astro";
import Head from "../components/Head.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import WalineComment from "../components/comments/WalineComment.vue";
import "../styles/layouts/BlogPost.css";
import "../styles/components/PostNavigation.css";
import { config_site } from "../utils/yaml-config-adapter";
import { description150 } from "../utils/description";
import "../styles/blog.css";
import "../styles/global.css";
import LeftSiderbar from "./LeftSiderbar.astro";
import RightSiderbar from "./RightSiderbar.astro";
import CC from "../components/others/CC.astro";
import "katex/dist/katex.min.css";
const {
	title,
	date,
	updated,
	tags,
	categories,
	headings = [],
	description,
	author,
	abbrlink,
	prev,
	next,
	minutesRead,
} = Astro.props;

function categoriesToString(categories?: string[]): string {
	if (!categories || categories.length === 0) {
		return "";
	}

	// ç°åœ¨ categories å·²ç»æ˜¯ç®€å•çš„å­—ç¬¦ä¸²æ•°ç»„ï¼Œç›´æ¥å¤„ç†å³å¯
	return categories
		.filter((cat) => cat && cat.trim() !== "") // è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
		.map((cat) => cat.trim()) // å»é™¤é¦–å°¾ç©ºæ ¼
		.join(","); // ç”¨é€—å·è¿æ¥
}

// å°†æ ‡ç­¾å’Œåˆ†ç±»åˆå¹¶å¹¶å»é‡
const combinedKeywords = new Set<string>();

// æ·»åŠ æ‰€æœ‰æ ‡ç­¾
if (tags && tags.length > 0) {
	tags.forEach((tag) => combinedKeywords.add(tag));
}

// æ·»åŠ æ‰€æœ‰åˆ†ç±»ï¼ˆå·²æ‰å¹³åŒ–ï¼‰
const categoryArray = categories
	? categoriesToString(categories)
			.split(",")
			.filter((cat) => cat.trim() !== "")
	: [];
categoryArray.forEach((category) => {
	combinedKeywords.add(category.trim());
});

// è½¬æ¢ä¸ºé€—å·åˆ†éš”çš„å­—ç¬¦ä¸²
const keyws =
	combinedKeywords.size > 0
		? Array.from(combinedKeywords).slice(0, 10).join(",")
		: "";

const categoryStr = categoriesToString(categories);
---

<html lang={config_site.lang} class="dark">
	<Head
		title={title + " | " + config_site.siteName}
		description={description150(description || "è¿™æ˜¯é»˜è®¤çš„æ–‡ç« æè¿°")}
		author={author || config_site.author}
		url={config_site.url + "/posts/" + abbrlink}
		canonical={config_site.url + "/posts/" + abbrlink}
		keywords={keyws || "å…³é”®å­—1, å…³é”®å­—2"}
		structuredData={{
			"@context": "https://schema.org",
			"@type": "BlogPosting",
			headline: title,
			description: description150(description || "è¿™æ˜¯é»˜è®¤çš„æ–‡ç« æè¿°"),
			author: {
				"@type": "Person",
				name: author || config_site.author,
			},
			datePublished: date,
			dateModified: updated || date,
			mainEntityOfPage: {
				"@type": "WebPage",
				"@id": config_site.url + "/posts/" + abbrlink,
			},
		}}
	>
		<!-- Vercountç»Ÿè®¡è„šæœ¬ -->
		<script defer src="https://events.vercount.one/js"></script>
	</Head>
	<body>
		<Header />
		<main>
			<div class="main-content">
				<LeftSiderbar />
				<article class="article-content">
					<div class="hero-image">
						<!-- å¦‚æœæœ‰ç‰¹è‰²å›¾ç‰‡å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ  -->
					</div>
					<div class="prose fade-in-up delay-200">
						<div class="title">
							<h1>{title}</h1>
							<div class="date">
								{
									date && (
										<div class="published-on">
											å‘å¸ƒæ—¶é—´ï¼š
											<time>
												{date instanceof Date
													? date.toLocaleDateString('zh-CN')
													: date}
											</time>
										</div>
									)
								}
								{
									updated && (
										<div class="last-updated-on">
											æ›´æ–°æ—¶é—´ï¼š
											<time>
												{updated instanceof Date
													? updated.toLocaleDateString('zh-CN')
													: updated}
											</time>
										</div>
									)
								}
							</div>
							<!-- æ–‡ç« é˜…è¯»é‡ç»Ÿè®¡ -->
							<div class="page-stats">
								{minutesRead && (
									<span class="reading-time">
										ğŸ•’ é˜…è¯»æ—¶é—´ï¼š{minutesRead}
									</span>
								)}
								<span id="vercount_container_page_pv">
									ğŸ‘€ é˜…è¯»é‡ï¼š<span id="vercount_value_page_pv">Loading...</span>
								</span>
							</div>
						</div>
						<slot />
					</div>
					<CC
						title={title}
						author={config_site.author}
						url={config_site.url + "/posts/" + abbrlink}
					/>
					{
						prev || next ? (
							<nav class="post-navigation" aria-label="æ–‡ç« å¯¼èˆª">
								<div class="post-navigation-inner">
									{prev ? (
										<a
											href={prev.url}
											class="post-nav-link prev-post"
											rel="prev"
										>
											<span class="post-nav-arrow">
												<svg
													xmlns="http://www.w3.org/2000/svg"
													viewBox="0 0 24 24"
													width="24"
													height="24"
													fill="none"
													stroke="currentColor"
													stroke-width="2"
													stroke-linecap="round"
													stroke-linejoin="round"
												>
													<path d="M19 12H5M12 19l-7-7 7-7" />
												</svg>
											</span>
											<div class="post-nav-content">
												<span class="post-nav-label">
													ä¸Šä¸€ç¯‡
												</span>
												<span class="post-nav-title">
													{prev.title}
												</span>
											</div>
										</a>
									) : (
										<span class="post-nav-link prev-post disabled">
											<span class="post-nav-arrow">
												<svg
													xmlns="http://www.w3.org/2000/svg"
													viewBox="0 0 24 24"
													width="24"
													height="24"
													fill="none"
													stroke="currentColor"
													stroke-width="2"
													stroke-linecap="round"
													stroke-linejoin="round"
												>
													<path d="M19 12H5M12 19l-7-7 7-7" />
												</svg>
											</span>
											<div class="post-nav-content">
												<span class="post-nav-label">
													ä¸Šä¸€ç¯‡
												</span>
												<span class="post-nav-title">
													æ²¡æœ‰æ›´æ—©çš„æ–‡ç« 
												</span>
											</div>
										</span>
									)}

									{next ? (
										<a
											href={next.url}
											class="post-nav-link next-post"
											rel="next"
										>
											<div class="post-nav-content">
												<span class="post-nav-label">
													ä¸‹ä¸€ç¯‡
												</span>
												<span class="post-nav-title">
													{next.title}
												</span>
											</div>
											<span class="post-nav-arrow">
												<svg
													xmlns="http://www.w3.org/2000/svg"
													viewBox="0 0 24 24"
													width="24"
													height="24"
													fill="none"
													stroke="currentColor"
													stroke-width="2"
													stroke-linecap="round"
													stroke-linejoin="round"
												>
													<path d="M5 12h14M12 5l7 7-7 7" />
												</svg>
											</span>
										</a>
									) : (
										<span class="post-nav-link next-post disabled">
											<div class="post-nav-content">
												<span class="post-nav-label">
													ä¸‹ä¸€ç¯‡
												</span>
												<span class="post-nav-title">
													æ²¡æœ‰æ›´æ–°çš„æ–‡ç« 
												</span>
											</div>
											<span class="post-nav-arrow">
												<svg
													xmlns="http://www.w3.org/2000/svg"
													viewBox="0 0 24 24"
													width="24"
													height="24"
													fill="none"
													stroke="currentColor"
													stroke-width="2"
													stroke-linecap="round"
													stroke-linejoin="round"
												>
													<path d="M5 12h14M12 5l7 7-7 7" />
												</svg>
											</span>
										</span>
									)}
								</div>
							</nav>
						) : null
					}
					<WalineComment
						serverURL={config_site.comment?.waline?.serverURL}
						path={Astro.url.pathname}
						title={title}
						lang={config_site.comment?.waline?.lang || "zh-CN"}
						emoji={config_site.comment?.waline?.emoji}
						reaction={config_site.comment?.waline?.reaction}
						meta={config_site.comment?.waline?.meta as import('@waline/client').WalineMeta[] | undefined}
						wordLimit={config_site.comment?.waline?.wordLimit}
						pageSize={config_site.comment?.waline?.pageSize}
						client:idle
					/>
				</article>
				<RightSiderbar {tags} {categories} {headings} />
			</div>
		</main>
		<Footer />
	</body><script>
		import "../scripts/background.ts";
		import "../scripts/fancybox.ts";
					import panZoomTiger  from "svg-pan-zoom";
		// ä¸ºæ–‡ç« å†…å®¹ä¸­çš„æ‰€æœ‰å›¾ç‰‡æ·»åŠ æ‡’åŠ è½½
		document.addEventListener("DOMContentLoaded", () => {
			const articleImages = document.querySelectorAll(
				".article-content img",
			);

			// ä¸ºæ¯ä¸ªå›¾ç‰‡æ·»åŠ æ‡’åŠ è½½å±æ€§
			articleImages.forEach((img) => {
				// å¦‚æœæ²¡æœ‰loadingå±æ€§ï¼Œæ·»åŠ loading="lazy"
				if (!img.hasAttribute("loading")) {
					img.setAttribute("loading", "lazy");
				}

				// æ·»åŠ æ·¡å…¥æ•ˆæœç±»
				img.classList.add("lazy-image");

				// ç›‘å¬å›¾ç‰‡åŠ è½½å®Œæˆäº‹ä»¶
				img.addEventListener("load", () => {
					img.classList.add("loaded");
				});

				// å¤„ç†å›¾ç‰‡åŠ è½½é”™è¯¯
				img.addEventListener("error", () => {
					console.warn(
						"å›¾ç‰‡åŠ è½½å¤±è´¥:",
						(img as HTMLImageElement).src,
					);
					// å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä¸€ä¸ªå ä½å›¾
					// (img as HTMLImageElement).src = '/images/placeholder.svg';
				});
			});

			// ä½¿ç”¨ Intersection Observer API ç›‘æµ‹å›¾ç‰‡å¯è§æ€§
			if ("IntersectionObserver" in window) {
				const imageObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							if (entry.isIntersecting) {
								const img = entry.target;
								// å¦‚æœæœ‰data-srcå±æ€§ï¼Œåˆ™åŠ è½½è¯¥å›¾ç‰‡
								const dataSrc = img.getAttribute("data-src");
								if (dataSrc) {
									(img as HTMLImageElement).src = dataSrc;
									img.removeAttribute("data-src");
								}
								imageObserver.unobserve(img);
							}
						});
					},
					{
						rootMargin: "200px 0px", // æå‰200pxåŠ è½½
						threshold: 0.01,
					},
				);

				// è§‚å¯Ÿæ‰€æœ‰å›¾ç‰‡
				articleImages.forEach((img) => {
					imageObserver.observe(img);
				});
			}
		});
		// å®šä¹‰åº”ç”¨ panZoomTiger çš„å‡½æ•°
		function applyPanZoomToMermaid(retryCount = 0, maxRetries = 10) {
		  let svgs = document.querySelectorAll("[id^='mermaid-']");
		  console.log('Found Mermaid SVGs:', svgs.length);
		  if (!svgs || svgs.length === 0) {
		    // å¦‚æœæ²¡æœ‰æ‰¾åˆ° SVGï¼Œä¸”é‡è¯•æ¬¡æ•°æœªè¾¾åˆ°ä¸Šé™ï¼Œåˆ™å»¶è¿Ÿé‡è¯•
		    if (retryCount < maxRetries) {
		      console.log(`No Mermaid SVGs found, retrying in 500ms (attempt ${retryCount + 1}/${maxRetries})`);
		      setTimeout(() => applyPanZoomToMermaid(retryCount + 1, maxRetries), 500);
		    } else {
		      console.log('Max retries reached, no Mermaid SVGs found');
		    }
		    return;
		  }
		  svgs.forEach((svg, index) => {
		    // æ£€æŸ¥æ˜¯å¦å·²ç»åº”ç”¨è¿‡ panZoomTiger
		    if ((svg as any)._panZoomTiger) {
		      console.log('SVG', index, 'already has panZoomTiger applied');
		      return;
		    }
		    (svg as SVGElement).style.height = '500px';
		    (svg as SVGElement).style.width = '100%';
		    console.log('Processing SVG', index, ':', svg.id, svg);
		    if (svg instanceof SVGElement) {
		      try {
		        const panZoomInstance = panZoomTiger(svg, {
		          zoomEnabled: true,
		          controlIconsEnabled: true,
		          fit: false,
		          center: true,
		        });
		        // æ ‡è®°å·²åº”ç”¨
		        (svg as any)._panZoomTiger = panZoomInstance;
		        console.log('Applied panZoomTiger to SVG', index);
		        // åˆ é™¤çˆ¶ DOM ä»¥é˜²æ­¢é®ç›–
		        if (svg.parentElement) {
		          const parent = svg.parentElement;
		          if (parent.parentElement) {
		            parent.parentElement.insertBefore(svg, parent);
		            parent.remove();
		            console.log('Removed parent DOM for SVG', index);
		          }
		        }
		      } catch (error) {
		        console.error('Error applying panZoomTiger to SVG', index, ':', error);
		      }
		    } else {
		      console.warn('Element is not SVGElement:', svg);
		    }
		  });
		}

		// åˆå§‹é¡µé¢åŠ è½½æ—¶åº”ç”¨
		document.addEventListener('DOMContentLoaded', () => applyPanZoomToMermaid());

		// è§†å›¾è¿‡æ¸¡é¡µé¢åŠ è½½æ—¶é‡æ–°åº”ç”¨ï¼ˆæ·»åŠ å»¶è¿Ÿä»¥ç¡®ä¿ DOM æ›´æ–°ï¼‰
		document.addEventListener('astro:page-load', () => {
		  setTimeout(() => applyPanZoomToMermaid(), 100);
		});

		// ä½¿ç”¨ MutationObserver ç›‘å¬åŠ¨æ€æ·»åŠ çš„ Mermaid SVG
		const observer = new MutationObserver((mutations) => {
		  mutations.forEach((mutation) => {
		    if (mutation.type === 'childList') {
		      mutation.addedNodes.forEach((node) => {
		        if (node.nodeType === Node.ELEMENT_NODE) {
		          const element = node as Element;
		          // æ£€æŸ¥æ–°æ·»åŠ çš„å…ƒç´ æ˜¯å¦åŒ…å« Mermaid SVG
		          const mermaidSvgs = element.querySelectorAll("[id^='mermaid-']");
		          if (mermaidSvgs.length > 0) {
		            console.log('Detected new Mermaid SVGs via MutationObserver');
		            applyPanZoomToMermaid();
		          }
		          // ä¹Ÿæ£€æŸ¥å…ƒç´ æœ¬èº«æ˜¯å¦æ˜¯ Mermaid SVG
		          if (element.id && element.id.startsWith('mermaid-')) {
		            console.log('Detected new Mermaid SVG element via MutationObserver');
		            applyPanZoomToMermaid();
		          }
		        }
		      });
		    }
		  });
		});
	</script>
	<!-- æ·»åŠ å“åº”å¼è§†å£è®¾ç½® -->
	<style>
		/* å›¾ç‰‡æ‡’åŠ è½½ç›¸å…³æ ·å¼ */
		.lazy-image {
			opacity: 0;
			transition: opacity 0.5s ease;
		}

		.lazy-image.loaded {
			opacity: 1;
		}
		/* æ–‡ç« é¡µé¢ç»Ÿè®¡æ ·å¼ */
		.page-stats {
			margin-top: 1rem;
			padding-top: 0.8rem;
			border-top: 1px solid rgba(255, 255, 255, 0.1);
			font-size: 0.9rem;
			color: rgba(255, 255, 255, 0.7);
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 1rem;
		}

		.page-stats span {
			display: inline-flex;
			align-items: center;
			gap: 0.3rem;
		}
		#vercount_value_page_pv {
			font-weight: 600;
			color: rgba(255, 255, 255, 0.9);
		}

		#vercount_container_page_pv {
			transition: opacity 0.3s ease;
		}

		/* å“åº”å¼è®¾è®¡ */
		@media (max-width: 768px) {
			.page-stats {
				font-size: 0.85rem;
				margin-top: 0.8rem;
				padding-top: 0.6rem;
			}
		}
	</style>
</html>
